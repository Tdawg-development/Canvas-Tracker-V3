
/**
 * Temporary execution script for Bulk Canvas Course Synchronization
 * Generated by TypeScript Executor for all available courses
 */

import { CanvasDataConstructor } from './staging/canvas-data-constructor';

async function executeBulkCanvasCourseSync() {
    try {
        console.log('üöÄ Starting Bulk Canvas Course Synchronization...');
        
        // Create constructor with optional configuration
        const config = undefined;
        const constructor = new CanvasDataConstructor(config ? { config } : undefined);
        
        // Get all available courses first
        console.log('üìã Fetching all available courses...');
        const allCourses = await constructor.getAllActiveCoursesStaging();
                console.log(`‚úÖ Found ` + allCourses.length + ` available courses to sync`);
        
        // Process each course with full data
        const coursesData = [];
        let successCount = 0;
        let errorCount = 0;
        const errors = [];
        
        for (let i = 0; i < allCourses.length; i++) {
            const courseStaging = allCourses[i];
            const courseId = courseStaging.id;
            
            try {
                console.log(`
üîÑ Processing course ` + (i + 1) + `/` + allCourses.length + `: ` + courseStaging.name + ` (ID: ` + courseId + `)`);
                
                // Get full course data including students, assignments, etc.
                const fullCourseData = await constructor.constructCourseData(courseId);
                
                // Convert to JSON-serializable format
                const courseResult = {
                    course_id: courseId,
                    course: {
                        id: fullCourseData.id,
                        name: fullCourseData.name,
                        course_code: fullCourseData.course_code,
                        workflow_state: fullCourseData.workflow_state,
                        start_at: fullCourseData.start_at,
                        end_at: fullCourseData.end_at,
                        created_at: fullCourseData.created_at,
                        updated_at: fullCourseData.updated_at,
                        calendar: fullCourseData.calendar
                    },
                    students: fullCourseData.students.map(student => ({
                        id: student.id,
                        user_id: student.user_id,
                        course_id: courseId,
                        created_at: student.created_at,
                        last_activity_at: student.last_activity_at,
                        current_score: student.current_score,
                        final_score: student.final_score,
                        enrollment_state: student.enrollment_state,
                        type: student.type,
                        grades: student.grades,
                        user: student.user,
                        submitted_assignments: student.submitted_assignments || [],
                        missing_assignments: student.missing_assignments || []
                    })),
                    modules: fullCourseData.modules.map(module => ({
                        id: module.id,
                        name: module.name,
                        position: module.position,
                        published: module.published,
                        course_id: courseId,
                        items: module.assignments.map(assignment => ({
                            id: assignment.id,
                            position: assignment.position,
                            published: assignment.published,
                            title: assignment.title,
                            type: assignment.type,
                            url: assignment.url,
                            content_details: assignment.content_details,
                            module_id: module.id,
                            course_id: courseId,
                            // Canvas API timestamp fields from enhancement
                            created_at: assignment.created_at,
                            updated_at: assignment.updated_at,
                            due_at: assignment.due_at,
                            lock_at: assignment.lock_at,
                            unlock_at: assignment.unlock_at,
                            workflow_state: assignment.workflow_state,
                            assignment_type: assignment.assignment_type,
                            points_possible: assignment.points_possible,
                            grading_type: assignment.grading_type,
                            submission_types: assignment.submission_types
                        }))
                    })),
                    metadata: {
                        execution_timestamp: new Date().toISOString(),
                        total_students: fullCourseData.students.length,
                        total_modules: fullCourseData.modules.length,
                        total_assignments: fullCourseData.getAllAssignments().length
                    }
                };
                
                coursesData.push(courseResult);
                successCount++;
                console.log(`‚úÖ Course ` + courseStaging.name + ` synced successfully (` + fullCourseData.students.length + ` students, ` + fullCourseData.getAllAssignments().length + ` assignments)`);
                
            } catch (courseError) {
                errorCount++;
                const errorMsg = `Failed to sync course ` + courseStaging.name + ` (ID: ` + courseId + `): ` + courseError.message;
                errors.push(errorMsg);
                console.error(`‚ùå ` + errorMsg);
                
                // Continue with next course instead of failing completely
                continue;
            }
        }
        
        // Prepare final result
        const result = {
            success: true,
            bulk_sync: true,
            total_courses_found: allCourses.length,
            courses_synced: successCount,
            courses_failed: errorCount,
            courses_data: coursesData,
            errors: errors,
            metadata: {
                execution_timestamp: new Date().toISOString(),
                total_execution_time: 'Calculated by Python',
                sync_summary: {
                    total_courses: allCourses.length,
                    successful_syncs: successCount,
                    failed_syncs: errorCount,
                    success_rate: allCourses.length > 0 ? Math.round((successCount / allCourses.length) * 100) : 0
                }
            }
        };
        
        console.log('
üéâ BULK SYNCHRONIZATION COMPLETED!');
        console.log('====================================');
        console.log(`üìä Total courses found: ` + allCourses.length);
        console.log(`‚úÖ Successfully synced: ` + successCount);
        console.log(`‚ùå Failed: ` + errorCount);
        console.log(`üìà Success rate: ` + result.metadata.sync_summary.success_rate + `%`);
        
        // Output JSON result for Python to parse
        console.log('
===CANVAS_BRIDGE_RESULT_START===');
        console.log(JSON.stringify(result, null, 2));
        console.log('===CANVAS_BRIDGE_RESULT_END===');
        
    } catch (error) {
        console.error('üí• Bulk Canvas synchronization failed:', error);
        
        // Output error in structured format
        const errorResult = {
            success: false,
            bulk_sync: true,
            error: {
                message: error.message || 'Unknown error',
                name: error.name || 'Error',
                stack: error.stack || 'No stack trace available'
            },
            execution_timestamp: new Date().toISOString()
        };
        
        console.log('
===CANVAS_BRIDGE_RESULT_START===');
        console.log(JSON.stringify(errorResult, null, 2));
        console.log('===CANVAS_BRIDGE_RESULT_END===');
        
        process.exit(1);
    }
}

// Execute the function
executeBulkCanvasCourseSync();
